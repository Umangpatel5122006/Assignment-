# -*- coding: utf-8 -*-
"""Lab4_Q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jzmp4LXDSp7PeCk_-1HCbYEKUYVW4ice
"""

from collections import defaultdict

graph = defaultdict(dict)

def add_edge(u,v,dist):
  graph[u][v]=dist
  graph[v][u]=dist
  graph[u][u]=0
  graph[v][v]=0

city_map={
    0 : "Chicago",
    1 : "Detroit",
    2 : "Cleveland",
    3 : "Indianapolis",
    4 : "Columbus",
    5 : "Buffalo",
    6 : "Pittsburgh",
    7 : "Syracuse",
    8 : "Philadelphia",
    9 : "Baltimore",
    10 : "New York",
    11 : "Providence",
    12 : "Boston",
    13 : "Portland"
}

add_edge(0,1,283)
add_edge(0,2,345)
add_edge(0,3,182)
add_edge(3,4,176)

add_edge(1,2,169)
add_edge(1,5,256)
add_edge(2,4,144)
add_edge(2,6,134)
add_edge(2,5,189)
add_edge(4,6,185)

add_edge(5,7,150)
add_edge(5,6,215)
add_edge(6,9,247)
add_edge(6,8,97)

add_edge(9,8,101)

add_edge(7,12,312)
add_edge(7,10,254)
add_edge(7,8,253)
add_edge(8,10,97)

add_edge(10,12,215)
add_edge(10,11,181)

add_edge(12,11,50)
add_edge(12,13,107)

cost_arr=[]
vis=set()
cost_curr=0

st_state=7
goal_state=0

class Node:
  def __init__(self,state,parent,action,path_cost):
    self.state = state
    self.parent = parent
    self.action = action
    self.path_cost = path_cost

  def __lt__(self, other):
    return self.path_cost < other.path_cost

class Problem:
  def __init__(self,start,goal,graph):
    self.initial_state=start
    self.goal_state=goal
    self.matrix=graph

  def initial(self):
    return self.initial_state

  def is_goal(self,state):
    return state==self.goal_state

  def actions(self,state):
    available_action=[]
    for neighbor_state in self.matrix[state].keys():
      if neighbor_state != state:
        available_action.append(neighbor_state)
    return available_action

  def result(self,state,action):
    return action

  def action_cost(self,St,a,end):
    return self.matrix[St][end]

def Expand(problem,node):
  new_nodes=[]
  s=node.state

  for action in problem.actions(s):
    new_state=problem.result(s,action)
    cost = node.path_cost + problem.action_cost(s,action,new_state)

    child= Node(state=new_state,parent=node,action=action,path_cost=cost)
    new_nodes.append(child)
  return new_nodes

class prio_queue:

  def __init__(self, l=None):
    self.l = l if l is not None else []
    if self.l:
      self.heapify()

  def isEmpty(self):
    return len(self.l) == 0

  def heapify(self):
    n = len(self.l)
    # Start from the last non-leaf node and go backwards to the root (index 0)
    # Last non-leaf node is at index (n // 2) - 1
    #              (start,stop,step)
    for i in range((n // 2) - 1, -1, -1):
        self._sift_down(i)


  def addlast(self, a):
    self.l.append(a)

    self._sift_up(len(self.l) - 1)

  def pop_left(self):
    if len(self.l) == 0:
      print("No ele to pop")
      return None

    temp = self.l[0]

    last_val = self.l.pop() # Removes the last element

    if len(self.l) > 0:
      self.l[0] = last_val
      # Push this new root down to its correct position
      self._sift_down(0)

    return temp

  def _sift_up(self, idx):
    parent = (idx - 1) // 2
    # While we are not at root AND current element is smaller than parent
    while idx > 0 and self.l[idx] < self.l[parent]:
      # Swap them
      self.l[idx], self.l[parent] = self.l[parent], self.l[idx]
      # Move up
      idx = parent
      parent = (idx - 1) // 2

  def _sift_down(self, idx):
    n = len(self.l)
    smallest = idx
    left_child = 2 * idx + 1
    right_child = 2 * idx + 2

    if left_child < n and self.l[left_child] < self.l[smallest]:
      smallest = left_child

    if right_child < n and self.l[right_child] < self.l[smallest]:
      smallest = right_child

    if smallest != idx:
      self.l[idx], self.l[smallest] = self.l[smallest], self.l[idx]
      self._sift_down(smallest)

def BestFirstSearch(problem):
    frontier = prio_queue()
    start=Node(state=problem.initial(),parent=None,action=None,path_cost=0)

    frontier.addlast(start)
    reached_lookup={problem.initial() : start}#return node by getting state

    while not frontier.isEmpty():
      node = frontier.pop_left()

      if problem.is_goal(node.state):
        return node

      for child in Expand(problem,node):
        s=child.state
        if s not in reached_lookup or child.path_cost < reached_lookup[s].path_cost:
          reached_lookup[s]=child
          frontier.addlast(child)
    return None

def best_way(goal_node):
  way = []
  node = goal_node

  while node is not None:
    way.append(node.state)
    node = node.parent

  way.reverse()
  return way

myprob= Problem(st_state,goal_state,graph)
result_node = BestFirstSearch(myprob)
if result_node:
  print(f"Path from {city_map[st_state]} to {city_map[goal_state]}: {best_way(result_node)}")
  print(f"Total cost: {result_node.path_cost}")
else:
  print(f"No path found from {city_map[st_state]} to {city_map[goal_state]}")