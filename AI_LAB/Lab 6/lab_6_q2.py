# -*- coding: utf-8 -*-
"""Lab_6_Q2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PmqWfINfCpxBCagSaF-WAtUiC5FCpofS
"""

class minHeap:
    def __init__(self):
        self.heap = []

    def parent(self,i):
        return (i-1)//2

    def left(self, i):
        return 2*i+1

    def right(self, i):
        return 2*i+2

    def swap(self,i,j):
        self.heap[i],self.heap[j] = self.heap[j], self.heap[i]

    def push(self,value):
        self.heap.append(value)
        self.heapify_up(len(self.heap)-1)

    def heapify_up(self,index):
        while index >0 and self.heap[self.parent(index)] > self.heap[index]:
            self.swap(index,self.parent(index))
            index = self.parent(index)

    def pop(self):
        if len(self.heap) == 0:
            raise IndexError("Empty Heap")

        root = self.heap[0]

        if len(self.heap) == 1:
            self.heap.pop()
            return root

        # move last element to root, then heapify down
        self.heap[0] = self.heap.pop()
        self.heapify_down(0)
        return root

    def heapify_down(self,index):
        smallest = index
        left = self.left(index)
        right = self.right(index)

        if left < len(self.heap) and self.heap[smallest] > self.heap[left]:
            smallest = left

        if right < len(self.heap) and self.heap[smallest] > self.heap[right]:
            smallest = right

        if smallest != index:
            self.swap(index, smallest)

            self.heapify_down(smallest)

    def peek(self):
        if not self.heap:
            raise IndexError("Empty Heap")
        return self.heap[0]

    def size(self):
        return len(self.heap)

    def is_empty(self):
        return len(self.heap) ==0

class Node:

    def __init__(self,state, parent = None, path_cost =0,h_n=0,f_value=0):
        self.state = state
        self.parent = parent
        self.path_cost = path_cost
        self.h_n=h_n
        self.f_value = f_value

    def __lt__(self,other):
        return self.f_value < other.f_value

def get_path(node):
    path = []
    while node:
        path.append(node.state)
        node = node.parent
    return path[::-1] # give path in reversed order

# import numpy as np

# m=int(input("Enter value of rows : "))
# n=int(input("Enter value of cols : "))
# grid=np.zeros((m,n))
# grid

# p = int(input("Enter number of pairs of obstacles: "))
# obs_cordinate = []

# for _ in range(p):
#     x, y = map(int, input("Enter two integers separated by space: ").split())
#     obs_cordinate.append((x, y))

# for x,y in obs_cordinate:
#   grid[x][y]=1
# grid

# x, y = map(int, input("Enter two integers separated by space for Starting state: ").split())
# start=(x,y)
# grid[x][y]=2

# r = int(input("Enter number of pairs of rewards: "))
# rewards_cordinate = []

# for _ in range(p):
#     x, y = map(int, input("Enter two integers separated by space: ").split())
#     rewards_cordinate.append((x, y))

# for x,y in obs_cordinate:
#   grid[x][y]=3
# grid

"""

0 = free corridor
1 = wall/room (blocked)
2 = start
3 = rewards
"""

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

import numpy as np

def a_star(grid, start, goal):
    """Finds the shortest path from start to a single goal using A*."""
    rows, cols = grid.shape
    open_list = minHeap()

    # h_n is Manhattan distance to the specific goal
    start_h = manhattan_distance(start, goal)
    start_node = Node(state=start, parent=None, path_cost=0, h_n=start_h, f_value=start_h)

    open_list.push(start_node)
    visited = {} # state -> best path_cost found so far

    while not open_list.is_empty():
        current_node = open_list.pop()

        if current_node.state == goal:
            return get_path(current_node), current_node.path_cost

        if current_node.state in visited and visited[current_node.state] <= current_node.path_cost:
            continue

        visited[current_node.state] = current_node.path_cost


        moves = [(-1,0), (1,0), (0,-1), (0,1)]  # up, down, left, right
        for dx, dy in moves:
            next_st = (current_node.state[0] + dx, current_node.state[1] + dy)

            # Check boundaries and walls (1)
            if 0 <= next_st[0] < rows and 0 <= next_st[1] < cols:
                if grid[next_st[0]][next_st[1]] != 1:
                    g_n = current_node.path_cost + 1
                    h_n = manhattan_distance(next_st, goal)
                    f_n = g_n + h_n
                    neighbor = Node(next_st, current_node, g_n, h_n, f_n)
                    open_list.push(neighbor)

    return None, float('inf')

m, n = 5, 5
grid = np.zeros((m, n))

# Based on image: Walls at (0,4), (1,1), (2,3), (2,4), (3,1), (3,4), (4,4)
obs_cordinate = [(0,4), (1,1), (2,3), (2,4), (3,1), (3,4)]
for x, y in obs_cordinate: grid[x][y] = 1

start = (0, 0)
grid[start] = 2

# Based on  image: Rewards at (1,4), (2,1), (4,0), (4,4)
rewards = [(1,4), (2,1), (4,0), (4,4)]
for x, y in rewards: grid[x][y] = 3

print("Initial Grid State:")
print(grid)

def solve_maze(grid, start, rewards):
    current_pos = start
    remaining_rewards = list(rewards)
    total_path = [start]
    total_cost = 0

    print(f"\nStarting traversal from {start}...")

    while remaining_rewards:
        # Greedy Choice: Find the closest reward from the current position
        best_path = None
        closest_reward = None
        min_dist = float('inf')

        for r in remaining_rewards:
            path, cost = a_star(grid, current_pos, r)
            if cost < min_dist:
                min_dist = cost
                best_path = path
                closest_reward = r

        if best_path:
            # Add path to total (excluding the first element to avoid duplicates)
            total_path.extend(best_path[1:])
            total_cost += min_dist
            current_pos = closest_reward
            remaining_rewards.remove(closest_reward)
            print(f"Reached reward at {closest_reward}. Steps: {min_dist}")
        else:
            print("Unreachable reward detected!")
            break

    return total_path, total_cost

full_path, cost = solve_maze(grid, start, rewards)
print("\n--- Final Results ---")
print(f"Total Tiles Visited in Order: {full_path}")
print(f"Total Path Cost: {cost}")