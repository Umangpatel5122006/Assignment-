# -*- coding: utf-8 -*-
"""Lab1_q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HVeQbPdMF1o9H7IrVtijk2WETZnh_gFh
"""

from collections import defaultdict

graph = defaultdict(list)#Create empty list if key doesn't exist key

def add_edge(u,v,dist):
  graph[u].append([v,dist])
  graph[v].append([u,dist])

add_edge("Chicago","Detroit",283)
add_edge("Chicago","Cleveland",345)
add_edge("Chicago","Indianapolis",182)
add_edge("Indianapolis","Columbus",176)

add_edge("Detroit","Cleveland",169)
add_edge("Detroit","Buffalo",256)
add_edge("Cleveland","Columbus",144)
add_edge("Cleveland","Pittsburgh",134)
add_edge("Cleveland","Buffalo",189)
add_edge("Columbus","Pittsburgh",185)

add_edge("Buffalo","Syracuse",150)
add_edge("Buffalo","Pittsburgh",215)
add_edge("Pittsburgh","Baltimore",247)
add_edge("Pittsburgh","Philadelphia",97)

add_edge("Baltimore","Philadelphia",101)

add_edge("Syracuse","Boston",312)
add_edge("Syracuse","New York",254)
add_edge("Syracuse","Philadelphia",253)
add_edge("Philadelphia","New York",97)

add_edge("New York","Boston",215)
add_edge("New York","Providence",181)

add_edge("Boston","Providence",50)
add_edge("Boston","Portland",107)

graph["Chicago"]

cost_arr=[]
vis=set()
cost_curr=0

#starting point is Syracuse
#Destination is Chicago

def dfs(st,dest,vis,graph,cost_arr,cost_curr):

  vis.add(st)

  if st==dest:

    cost_arr.append(cost_curr)

    vis.remove(st)

    return
  for neighbour,dist1 in graph[st]:

    if neighbour not in vis:

      dfs(neighbour,dest,vis,graph,cost_arr,cost_curr+dist1)



  vis.remove(st)

dfs("Syracuse","Chicago",vis,graph,cost_arr,0)

print("Total paths found using DFS:", len(cost_arr))

print("Minimum cost path using DFS:", min(cost_arr) if cost_arr else None)



"""# Q1 implementation BFS"""

from collections import deque

def bfs(start, dest, graph):
    queue = deque()
    queue.append((start, 0, set([start]),[]))   # (city, cost, visited set,exp_cost_arr)
    costs = []

    while queue:
        city, cost, visited,exp_cost = queue.popleft()

        if city == dest:
            costs.append((cost,exp_cost))

            continue

        for neighbour, dist in graph[city]:
            if neighbour not in visited:
                new_visited = visited.copy()   # make a copy for this path
                branch_exp= exp_cost.copy()
                new_visited.add(neighbour)
                branch_exp.append(dist)
                queue.append((neighbour, cost + dist, new_visited,branch_exp))

    return costs

bfs("Syracuse", "Chicago", graph)

costs = bfs("Syracuse", "Chicago", graph)
print("total path using BFS:", len(costs))
print("Minimum cost path using BFS:", min(costs) if costs else None)


print("")
print("ALL paths cost using DFS")
print("")
print("")
print(cost_arr)
print("")
print("")
print("ALL paths using BFS")
print("")
print("")
print(costs)