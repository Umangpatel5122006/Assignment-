# -*- coding: utf-8 -*-
"""Lab5_Q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o-mv8DkUCahfZrA0Sn6qZ9-ebpkJvyXl
"""

class Node:
    def __init__(self, girls_left, boys_left, boat_on_left, parent=None, action="", depth=0):

        self.girls_left = girls_left
        self.boys_left = boys_left
        self.boat_on_left = boat_on_left # 1 for boat at left bank
        self.parent = parent
        self.action = action
        self.depth = depth

    def is_goal(self):
        return self.girls_left == 0 and self.boys_left == 0 and self.boat_on_left == 0

    def is_valid(self):
        m_right = 3 - self.girls_left
        c_right = 3 - self.boys_left

        if self.girls_left < 0 or self.boys_left < 0 or m_right < 0 or c_right < 0:
            return False

        if self.girls_left > 0 and self.boys_left > self.girls_left:
            return False

        if m_right > 0 and c_right > m_right:
            return False

        return True

moves = [# move (girls,boys) on boat
            (1, 0),
            (2, 0),
            (0, 1),
            (0, 2),
            (1, 1)
]

def expand(node):
  children=[] # Initialize children list once
  for girl_move,boy_move in moves:

    if node.boat_on_left:#new member add on left bank

      new_girls=node.girls_left-girl_move # Boat moves from left, so people leave left bank
      new_boys=node.boys_left-boy_move
      boat_state=0
      action_name= f"Move {girl_move} girl and {boy_move} to right river bank"

    else:# add on right

      new_girls=node.girls_left+girl_move # Boat moves from right, so people added on left bank
      new_boys=node.boys_left+boy_move
      boat_state=1
      action_name= f"Move {girl_move} girl and {boy_move} to left river bank"

    child=Node(new_girls,new_boys,boat_state,node,action_name,node.depth+1)

    if child.is_valid():
      children.append(child)
  return children

class mystack():
  def __init__(self):
    self.l=[]

  def add(self,ele):
    self.l.append(ele)

  def pop(self):
    if(len(self.l)>0):
      return self.l.pop()
    else:
      print("Stack is empty")

  def is_empty(self):
    return len(self.l)==0

def Depth_ltd_search(limit,start_node):
  frontier=mystack()
  reached=set()
  dls_explored_count = 0

  frontier.add(start_node)

  while not frontier.is_empty():

    node = frontier.pop()
    dls_explored_count+=1
    current_state_tuple = (node.girls_left, node.boys_left, node.boat_on_left)

    if current_state_tuple in reached:
        continue
    reached.add(current_state_tuple)

    if node.is_goal():
      return node, dls_explored_count

    if node.depth < limit:
      for child in expand(node):
            child_state_tuple = (child.girls_left, child.boys_left, child.boat_on_left)
            if child_state_tuple not in reached: # unvisited children to frontier
                    frontier.add(child)
  return None, dls_explored_count # Return None only if the entire search finishes without finding the goal

def print_path(node, total_explored_states_count):
    if node is None:
        print("Cutoff occurred â€” Goal not found within depth limit or no solution exists.")
        return

    path = []
    while node:
        path.append(node)
        node = node.parent

    path.reverse()
    print(f"\n Total Explored States {total_explored_states_count}")
    print("\nSolution Steps:")
    for i, p_node in enumerate(path):
        state_desc = f"({p_node.girls_left} Girls, {p_node.boys_left} Boys on Left; {3-p_node.girls_left} Girls, {3-p_node.boys_left} Boys on Right)"
        if i == 0:
            print(f"Initial State: {state_desc}")
        else:
            print("------------------------------------")
            print(f"Step {i} action: {p_node.action}")
            print(f"Girls on left: {p_node.girls_left}")
            print(f"Boys on left: {p_node.boys_left}")
            print(f"Girls on Right: {3-p_node.girls_left}")
            print(f"Boys on Right: {3-p_node.boys_left}")
            print("------------------------------------")

start_state = Node(3, 3, 1)
depth_limit = 3

print(f"Starting Depth-Limited Search with limit = {depth_limit}")
goal_node, dls_explored_count = Depth_ltd_search(depth_limit, start_state)

print_path(goal_node, dls_explored_count)

"""# Iterative Deepening Search
  
"""

def Iterative_deepening_search(start_state):

  print("Starting Iterative Deepening Search...")

  for depth in range(0, 100):

    print(f"  Searching at depth limit = {depth}")

    result = Depth_ltd_search(depth, start_state,explored_states)

    if result:

      print(f"Solution found at depth {depth}!")
      print_path(result)
      return result

  print("No solution found within the maximum depth of 99.")

  return None

def Iterative_deepening_search(start_state):

  print("Starting Iterative Deepening Search...")
  total_ids_explored_count = 0 # Initialize local counter for IDS

  for depth in range(0, 100):

    print(f"  Searching at depth limit = {depth}")

    dls_result, dls_explored_count = Depth_ltd_search(depth, start_state) # Update call to DLS
    total_ids_explored_count += dls_explored_count # Accumulate explored states

    if dls_result: # Change condition check

      print(f"Solution found at depth {depth}!")
      print_path(dls_result, total_ids_explored_count) # Update print_path call
      return dls_result

  print("No solution found within the maximum depth of 99.")

  return None

Iterative_deepening_search(start_state)

print("IDS states explored: 107 and TC : O(b^d)")
print ("DLS states explored : 12 and TC : O(b^l)")